--- a/go.go	2019-04-10 23:02:03.000000000 +0800
+++ b/go.go	2022-10-06 16:54:17.000000000 +0800
@@ -32,6 +32,7 @@ type CompileOpts struct {
 	Cgo         bool
 	Rebuild     bool
 	GoCmd       string
+	Race        bool
 }

 // GoCrossCompile
@@ -111,6 +112,9 @@ func GoCrossCompile(opts *CompileOpts) e
 	if opts.ModMode != "" {
 		args = append(args, "-mod", opts.ModMode)
 	}
+	if opts.Race {
+		args = append(args, "-race")
+	}
 	args = append(args,
 		"-gcflags", opts.Gcflags,
 		"-ldflags", opts.Ldflags,
--- a/go.mod	2019-04-10 23:02:03.000000000 +0800
+++ b/go.mod	2022-10-06 16:54:17.000000000 +0800
@@ -1,5 +1,7 @@
 module github.com/mitchellh/gox

+go 1.17
+
 require (
 	github.com/hashicorp/go-version v1.0.0
 	github.com/mitchellh/iochan v1.0.0
--- a/go.sum	2019-04-10 23:02:03.000000000 +0800
+++ b/go.sum	2022-10-06 16:54:17.000000000 +0800
@@ -1,6 +1,4 @@
 github.com/hashicorp/go-version v1.0.0 h1:21MVWPKDphxa7ineQQTrCU5brh7OuVVAzGOCnnCPtE8=
 github.com/hashicorp/go-version v1.0.0/go.mod h1:fltr4n8CU8Ke44wwGCBoEymUuxUHl09ZGVZPK5anwXA=
-github.com/mitchellh/iochan v0.0.0-20150529224432-87b45ffd0e95 h1:aHWVygBsLb+Kls/35B3tevL1hvDxZ0UklPA0BmhqTEk=
-github.com/mitchellh/iochan v0.0.0-20150529224432-87b45ffd0e95/go.mod h1:JwYml1nuB7xOzsp52dPpHFffvOCDupsG0QubkSMEySY=
 github.com/mitchellh/iochan v1.0.0 h1:C+X3KsSTLFVBr/tK1eYN/vs4rJcvsiLU338UhYPJWeY=
 github.com/mitchellh/iochan v1.0.0/go.mod h1:JwYml1nuB7xOzsp52dPpHFffvOCDupsG0QubkSMEySY=
--- a/go_test.go	2019-04-10 23:02:03.000000000 +0800
+++ b/go_test.go	2022-10-06 16:54:17.000000000 +0800
@@ -12,13 +12,26 @@ func TestGoVersion(t *testing.T) {
 	}

 	acceptable := []string{
-		"devel", "go1.0", "go1.1", "go1.2", "go1.3",
-		"go1.4", "go1.4.1", "go1.4.2", "go1.4.3",
-		"go1.5", "go1.5.1", "go1.5.2", "go1.5.3", "go1.5.4",
-		"go1.6", "go1.6.1", "go1.6.2", "go1.6.3", "go1.6.4",
-		"go1.7", "go1.7.1", "go1.7.2", "go1.7.3", "go1.7.4", "go1.7.5", "go1.7.6",
-		"go1.8", "go1.8.1", "go1.8.2", "go1.8.3", "go1.8.4",
-		"go1.9", "go1.9.1", "go1.9.2",
+		"devel",
+		"go1.0",
+		"go1.1",
+		"go1.2",
+		"go1.3",
+		"go1.4",
+		"go1.5",
+		"go1.6",
+		"go1.7",
+		"go1.8",
+		"go1.9",
+		"go1.10",
+		"go1.11",
+		"go1.12",
+		"go1.13",
+		"go1.14",
+		"go1.15",
+		"go1.16",
+		"go1.17",
+		"go1.18",
 	}
 	found := false
 	for _, expected := range acceptable { 			
--- a/main.go	2019-04-10 23:02:03.000000000 +0800
+++ b/main.go	2022-10-06 16:54:17.000000000 +0800
@@ -27,7 +27,7 @@ func realMain() int {
 	var tags string
 	var verbose bool
 	var flagGcflags, flagAsmflags string
-	var flagCgo, flagRebuild, flagListOSArch bool
+	var flagCgo, flagRebuild, flagListOSArch, flagRaceFlag bool
 	var flagGoCmd string
 	var modMode string
 	flags := flag.NewFlagSet("gox", flag.ExitOnError)
@@ -44,6 +44,7 @@ func realMain() int {
 	flags.BoolVar(&flagCgo, "cgo", false, "")
 	flags.BoolVar(&flagRebuild, "rebuild", false, "")
 	flags.BoolVar(&flagListOSArch, "osarch-list", false, "")
+	flags.BoolVar(&flagRaceFlag, "race", false, "")
 	flags.StringVar(&flagGcflags, "gcflags", "", "")
 	flags.StringVar(&flagAsmflags, "asmflags", "", "")
 	flags.StringVar(&flagGoCmd, "gocmd", "go", "")
@@ -162,6 +163,7 @@ func realMain() int {
 					Cgo:         flagCgo,
 					Rebuild:     flagRebuild,
 					GoCmd:       flagGoCmd,
+					Race:        flagRaceFlag,
 				}

 				// Determine if we have specific CFLAGS or LDFLAGS for this
@@ -219,6 +221,7 @@ Options:
   -osarch-list        List supported os/arch pairs for your Go version
   -output="foo"       Output path template. See below for more info
   -parallel=-1        Amount of parallelism, defaults to number of CPUs
+  -race               Build with the go race detector enabled, requires CGO
   -gocmd="go"         Build command, defaults to Go
   -rebuild            Force rebuilding of package that were up to date
   -verbose            Verbose mode

--- a/platform.go	2019-04-10 23:02:03.000000000 +0800
+++ b/platform.go	2022-10-06 16:54:17.000000000 +0800
@@ -25,6 +25,36 @@ func (p *Platform) String() string {
 	return fmt.Sprintf("%s/%s", p.OS, p.Arch)
 }

+// addDrop appends all of the "add" entries and drops the "drop" entries, ignoring
+// the "Default" parameter.
+func addDrop(base []Platform, add []Platform, drop []Platform) []Platform {
+	newPlatforms := make([]Platform, len(base)+len(add))
+	copy(newPlatforms, base)
+	copy(newPlatforms[len(base):], add)
+
+	// slow, but we only do this during initialization at most once per version
+	for _, platform := range drop {
+		found := -1
+		for i := range newPlatforms {
+			if newPlatforms[i].Arch == platform.Arch && newPlatforms[i].OS == platform.OS {
+				found = i
+				break
+			}
+		}
+		if found < 0 {
+			panic(fmt.Sprintf("Expected to remove %+v but not found in list %+v", platform, newPlatforms))
+		}
+		if found == len(newPlatforms)-1 {
+			newPlatforms = newPlatforms[:found]
+		} else if found == 0 {
+			newPlatforms = newPlatforms[found:]
+		} else {
+			newPlatforms = append(newPlatforms[:found], newPlatforms[found+1:]...)
+		}
+	}
+	return newPlatforms
+}
+
 var (
 	Platforms_1_0 = []Platform{
 		{"darwin", "386", true},
@@ -40,64 +70,115 @@ var (
 		{"windows", "amd64", true},
 	}

-	Platforms_1_1 = append(Platforms_1_0, []Platform{
+	Platforms_1_1 = addDrop(Platforms_1_0, []Platform{
 		{"freebsd", "arm", true},
 		{"netbsd", "386", true},
 		{"netbsd", "amd64", true},
 		{"netbsd", "arm", true},
 		{"plan9", "386", false},
-	}...)
+	}, nil)

-	Platforms_1_3 = append(Platforms_1_1, []Platform{
+	Platforms_1_3 = addDrop(Platforms_1_1, []Platform{
 		{"dragonfly", "386", false},
 		{"dragonfly", "amd64", false},
 		{"nacl", "amd64", false},
 		{"nacl", "amd64p32", false},
 		{"nacl", "arm", false},
 		{"solaris", "amd64", false},
-	}...)
+	}, nil)

-	Platforms_1_4 = append(Platforms_1_3, []Platform{
+	Platforms_1_4 = addDrop(Platforms_1_3, []Platform{
 		{"android", "arm", false},
 		{"plan9", "amd64", false},
-	}...)
+	}, nil)

-	Platforms_1_5 = append(Platforms_1_4, []Platform{
+	Platforms_1_5 = addDrop(Platforms_1_4, []Platform{
 		{"darwin", "arm", false},
 		{"darwin", "arm64", false},
 		{"linux", "arm64", false},
 		{"linux", "ppc64", false},
 		{"linux", "ppc64le", false},
-	}...)
+	}, nil)

-	Platforms_1_6 = append(Platforms_1_5, []Platform{
+	Platforms_1_6 = addDrop(Platforms_1_5, []Platform{
 		{"android", "386", false},
+		{"android", "amd64", false},
 		{"linux", "mips64", false},
 		{"linux", "mips64le", false},
-	}...)
+		{"nacl", "386", false},
+		{"openbsd", "arm", true},
+	}, nil)

-	Platforms_1_7 = append(Platforms_1_5, []Platform{
+	Platforms_1_7 = addDrop(Platforms_1_5, []Platform{
 		// While not fully supported s390x is generally useful
 		{"linux", "s390x", true},
 		{"plan9", "arm", false},
 		// Add the 1.6 Platforms, but reflect full support for mips64 and mips64le
 		{"android", "386", false},
+		{"android", "amd64", false},
 		{"linux", "mips64", true},
 		{"linux", "mips64le", true},
-	}...)
+		{"nacl", "386", false},
+		{"openbsd", "arm", true},
+	}, nil)

-	Platforms_1_8 = append(Platforms_1_7, []Platform{
+	Platforms_1_8 = addDrop(Platforms_1_7, []Platform{
 		{"linux", "mips", true},
 		{"linux", "mipsle", true},
-	}...)
+	}, nil)

 	// no new platforms in 1.9
 	Platforms_1_9 = Platforms_1_8

-	// no new platforms in 1.10
-	Platforms_1_10 = Platforms_1_9
+	// unannounced, but dropped support for android/amd64
+	Platforms_1_10 = addDrop(Platforms_1_9, nil, []Platform{{"android", "amd64", false}})
+
+	Platforms_1_11 = addDrop(Platforms_1_10, []Platform{
+		{"js", "wasm", true},
+	}, nil)
+
+	Platforms_1_12 = addDrop(Platforms_1_11, []Platform{
+		{"aix", "ppc64", false},
+		{"windows", "arm", true},
+	}, nil)
+
+	Platforms_1_13 = addDrop(Platforms_1_12, []Platform{
+		{"illumos", "amd64", false},
+		{"netbsd", "arm64", true},
+		{"openbsd", "arm64", true},
+	}, nil)
+
+	Platforms_1_14 = addDrop(Platforms_1_13, []Platform{
+		{"freebsd", "arm64", true},
+		{"linux", "riscv64", true},
+	}, []Platform{
+		// drop nacl
+		{"nacl", "386", false},
+		{"nacl", "amd64", false},
+		{"nacl", "arm", false},
+	})
+
+	Platforms_1_15 = addDrop(Platforms_1_14, []Platform{
+		{"android", "arm64", false},
+	}, []Platform{
+		// drop i386 macos
+		{"darwin", "386", false},
+	})
+
+	Platforms_1_16 = addDrop(Platforms_1_15, []Platform{
+		{"android", "amd64", false},
+		{"darwin", "arm64", true},
+		{"openbsd", "mips64", false},
+	}, nil)
+
+	Platforms_1_17 = addDrop(Platforms_1_16, []Platform{
+		{"windows", "arm64", true},
+	}, nil)
+
+	// no new platforms in 1.18
+	Platforms_1_18 = Platforms_1_17

-	PlatformsLatest = Platforms_1_10
+	PlatformsLatest = Platforms_1_18
 )

 // SupportedPlatforms returns the full list of supported platforms for
@@ -131,7 +212,15 @@ func SupportedPlatforms(v string) []Plat
 		{">= 1.7, < 1.8", Platforms_1_7},
 		{">= 1.8, < 1.9", Platforms_1_8},
 		{">= 1.9, < 1.10", Platforms_1_9},
-		{">=1.10, < 1.11", Platforms_1_10},
+		{">= 1.10, < 1.11", Platforms_1_10},
+		{">= 1.11, < 1.12", Platforms_1_11},
+		{">= 1.12, < 1.13", Platforms_1_12},
+		{">= 1.13, < 1.14", Platforms_1_13},
+		{">= 1.14, < 1.15", Platforms_1_14},
+		{">= 1.15, < 1.16", Platforms_1_15},
+		{">= 1.16, < 1.17", Platforms_1_16},
+		{">= 1.17, < 1.18", Platforms_1_17},
+		{">= 1.18, < 1.19", Platforms_1_18},
 	}

 	for _, p := range platforms {
@@ -145,5 +234,5 @@ func SupportedPlatforms(v string) []Plat
 	}

 	// Assume latest
-	return Platforms_1_9
+	return PlatformsLatest
 }
--- a/platform_test.go	2019-04-10 23:02:03.000000000 +0800
+++ b/platform_test.go	2022-10-06 16:54:17.000000000 +0800
@@ -63,6 +63,55 @@ func TestSupportedPlatforms(t *testing.T
 		t.Fatalf("bad: %#v", ps)
 	}

+	ps = SupportedPlatforms("go1.10")
+	if !reflect.DeepEqual(ps, Platforms_1_10) {
+		t.Fatalf("bad: %#v", ps)
+	}
+
+	ps = SupportedPlatforms("go1.11")
+	if !reflect.DeepEqual(ps, Platforms_1_11) {
+		t.Fatalf("bad: %#v", ps)
+	}
+
+	ps = SupportedPlatforms("go1.12")
+	if !reflect.DeepEqual(ps, Platforms_1_12) {
+		t.Fatalf("bad: %#v", ps)
+	}
+
+	ps = SupportedPlatforms("go1.13")
+	if !reflect.DeepEqual(ps, Platforms_1_13) {
+		t.Fatalf("bad: %#v", ps)
+	}
+
+	ps = SupportedPlatforms("go1.14")
+	if !reflect.DeepEqual(ps, Platforms_1_14) {
+		t.Fatalf("bad: %#v", ps)
+	}
+
+	ps = SupportedPlatforms("go1.15")
+	if !reflect.DeepEqual(ps, Platforms_1_15) {
+		t.Fatalf("bad: %#v", ps)
+	}
+
+	ps = SupportedPlatforms("go1.16")
+	if !reflect.DeepEqual(ps, Platforms_1_16) {
+		t.Fatalf("bad: %#v", ps)
+	}
+
+	ps = SupportedPlatforms("go1.17")
+	if !reflect.DeepEqual(ps, Platforms_1_17) {
+		t.Fatalf("bad: %#v", ps)
+	}
+
+	ps = SupportedPlatforms("go1.18")
+	if !reflect.DeepEqual(ps, Platforms_1_18) {
+		t.Fatalf("bad: %#v", ps)
+	}
+
+	ps = SupportedPlatforms("go1.10")
+	if !reflect.DeepEqual(ps, Platforms_1_10) {
+		t.Fatalf("bad: %#v", ps)
+	}
 	// Unknown
 	ps = SupportedPlatforms("foo")
 	if !reflect.DeepEqual(ps, PlatformsLatest) {
@@ -72,17 +121,30 @@ func TestSupportedPlatforms(t *testing.T

 func TestMIPS(t *testing.T) {
 	g16 := SupportedPlatforms("go1.6")
+	found := false
 	for _, p := range g16 {
-		if p.Arch == "mips64" && p.Default {
-			t.Fatal("mips64 should not be default for 1.6")
+		if p.OS == "linux" && p.Arch == "mips64" && !p.Default {
+			found = true
+		}
+		if p.OS == "linux" && p.Arch == "mips64" && p.Default {
+			t.Fatalf("mips64 should not be default for 1.6, but got %+v, %+v", p, g16)
 		}
 	}
+	if !found {
+		t.Fatal("Expected to find linux/mips64/false in go1.6 supported platforms")
+	}
+	found = false

 	g17 := SupportedPlatforms("go1.7")
 	for _, p := range g17 {
-		if p.Arch == "mips64" && !p.Default {
+		if p.OS == "linux" && p.Arch == "mips64" && p.Default {
+			found = true
+		}
+		if p.OS == "linux" && p.Arch == "mips64" && !p.Default {
 			t.Fatal("mips64 should be default for 1.7")
 		}
 	}
-
+	if !found {
+		t.Fatal("Expected to find linux/mips64/true in go1.7 supported platforms")
+	}
 }
--- a/vendor/github.com/hashicorp/go-version/constraint.go	2019-04-10 23:02:03.000000000 +0800
+++ b/vendor/github.com/hashicorp/go-version/constraint.go	2022-10-06 17:13:18.000000000 +0800
@@ -2,6 +2,7 @@ package version

 import (
 	"fmt"
+	"reflect"
 	"regexp"
 	"strings"
 )
@@ -113,6 +114,26 @@ func parseSingle(v string) (*Constraint,
 	}, nil
 }

+func prereleaseCheck(v, c *Version) bool {
+	switch vPre, cPre := v.Prerelease() != "", c.Prerelease() != ""; {
+	case cPre && vPre:
+		// A constraint with a pre-release can only match a pre-release version
+		// with the same base segments.
+		return reflect.DeepEqual(c.Segments64(), v.Segments64())
+
+	case !cPre && vPre:
+		// A constraint without a pre-release can only match a version without a
+		// pre-release.
+		return false
+
+	case cPre && !vPre:
+		// OK, except with the pessimistic operator
+	case !cPre && !vPre:
+		// OK
+	}
+	return true
+}
+
 //-------------------------------------------------------------------
 // Constraint functions
 //-------------------------------------------------------------------
@@ -126,22 +147,27 @@ func constraintNotEqual(v, c *Version) b
 }

 func constraintGreaterThan(v, c *Version) bool {
-	return v.Compare(c) == 1
+	return prereleaseCheck(v, c) && v.Compare(c) == 1
 }

 func constraintLessThan(v, c *Version) bool {
-	return v.Compare(c) == -1
+	return prereleaseCheck(v, c) && v.Compare(c) == -1
 }

 func constraintGreaterThanEqual(v, c *Version) bool {
-	return v.Compare(c) >= 0
+	return prereleaseCheck(v, c) && v.Compare(c) >= 0
 }

 func constraintLessThanEqual(v, c *Version) bool {
-	return v.Compare(c) <= 0
+	return prereleaseCheck(v, c) && v.Compare(c) <= 0
 }

 func constraintPessimistic(v, c *Version) bool {
+	// Using a pessimistic constraint with a pre-release, restricts versions to pre-releases
+	if !prereleaseCheck(v, c) || (c.Prerelease() != "" && v.Prerelease() == "") {
+		return false
+	}
+
 	// If the version being checked is naturally less than the constraint, then there
 	// is no way for the version to be valid against the constraint
 	if v.LessThan(c) {

--- a/vendor/github.com/hashicorp/go-version/version.go	2019-04-10 23:02:03.000000000 +0800
+++ b/vendor/github.com/hashicorp/go-version/version.go	2022-10-06 17:13:18.000000000 +0800
@@ -15,7 +15,7 @@ var versionRegexp *regexp.Regexp
 // The raw regular expression string used for testing the validity
 // of a version.
 const VersionRegexpRaw string = `v?([0-9]+(\.[0-9]+)*?)` +
-	`(-?([0-9A-Za-z\-~]+(\.[0-9A-Za-z\-~]+)*))?` +
+	`(-([0-9]+[0-9A-Za-z\-~]*(\.[0-9A-Za-z\-~]+)*)|(-?([A-Za-z\-~]+[0-9A-Za-z\-~]*(\.[0-9A-Za-z\-~]+)*)))?` +
 	`(\+([0-9A-Za-z\-~]+(\.[0-9A-Za-z\-~]+)*))?` +
 	`?`

@@ -25,6 +25,7 @@ type Version struct {
 	pre      string
 	segments []int64
 	si       int
+	original string
 }

 func init() {
@@ -59,11 +60,17 @@ func NewVersion(v string) (*Version, err
 		segments = append(segments, 0)
 	}

+	pre := matches[7]
+	if pre == "" {
+		pre = matches[4]
+	}
+
 	return &Version{
-		metadata: matches[7],
-		pre:      matches[4],
+		metadata: matches[10],
+		pre:      pre,
 		segments: segments,
 		si:       si,
+		original: v,
 	}, nil
 }

@@ -301,11 +308,19 @@ func (v *Version) Segments() []int {
 // for a version "1.2.3-beta", segments will return a slice of
 // 1, 2, 3.
 func (v *Version) Segments64() []int64 {
-	return v.segments
+	result := make([]int64, len(v.segments))
+	copy(result, v.segments)
+	return result
 }

 // String returns the full version string included pre-release
 // and metadata information.
+//
+// This value is rebuilt according to the parsed segments and other
+// information. Therefore, ambiguities in the version string such as
+// prefixed zeroes (1.04.0 => 1.4.0), `v` prefix (v1.0.0 => 1.0.0), and
+// missing parts (1.0 => 1.0.0) will be made into a canonicalized form
+// as shown in the parenthesized examples.
 func (v *Version) String() string {
 	var buf bytes.Buffer
 	fmtParts := make([]string, len(v.segments))
@@ -324,3 +339,9 @@ func (v *Version) String() string {

 	return buf.String()
 }
+
+// Original returns the original parsed version as-is, including any
+// potential whitespace, `v` prefix, etc.
+func (v *Version) Original() string {
+	return v.original
+}

--- a/vendor/modules.txt	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/modules.txt	2022-10-06 17:13:18.000000000 +0800
@@ -0,0 +1,6 @@
+# github.com/hashicorp/go-version v1.0.0
+## explicit
+github.com/hashicorp/go-version
+# github.com/mitchellh/iochan v1.0.0
+## explicit
+github.com/mitchellh/iochan
